---
// Snackbar 컴포넌트
---

<div id="snackbar-container" class="snackbar-container">
  <!-- Snackbar들이 동적으로 추가됩니다 -->
</div>

<script>
  class SnackbarManager {
    constructor() {
      this.container = document.getElementById('snackbar-container');
      this.snackbars = new Map();
      this.counter = 0;
    }

    show(message, type = 'info', duration = 4000) {
      const id = `snackbar-${++this.counter}`;
      const snackbar = this.createSnackbar(id, message, type);

      this.container.appendChild(snackbar);
      this.snackbars.set(id, snackbar);

      // 애니메이션 시작
      requestAnimationFrame(() => {
        snackbar.classList.add('show');
      });

      // 자동 제거
      if (duration > 0) {
        this.startProgress(id, duration);
        setTimeout(() => this.hide(id), duration);
      }

      return id;
    }

    createSnackbar(id, message, type) {
      const snackbar = document.createElement('div');
      snackbar.id = id;
      snackbar.className = `snackbar ${type}`;

      const icon = this.getIcon(type);

      snackbar.innerHTML = `
        <div class="snackbar-content">
          <div class="snackbar-icon">${icon}</div>
          <div class="snackbar-message">${this.escapeHtml(message)}</div>
          <button class="snackbar-close" onclick="snackbarManager.hide('${id}')">×</button>
        </div>
        <div class="snackbar-progress"></div>
      `;

      return snackbar;
    }

    getIcon(type) {
      const icons = {
        success: '✓',
        error: '✕',
        warning: '⚠',
        info: 'ℹ'
      };
      return icons[type] || icons.info;
    }

    startProgress(id, duration) {
      const snackbar = this.snackbars.get(id);
      if (!snackbar) return;

      const progress = snackbar.querySelector('.snackbar-progress');
      const startTime = Date.now();

      const updateProgress = () => {
        const elapsed = Date.now() - startTime;
        const percentage = Math.max(0, 100 - (elapsed / duration) * 100);
        progress.style.width = `${percentage}%`;

        if (percentage > 0) {
          requestAnimationFrame(updateProgress);
        }
      };

      requestAnimationFrame(updateProgress);
    }

    hide(id) {
      const snackbar = this.snackbars.get(id);
      if (!snackbar) return;

      snackbar.classList.add('hide');

      setTimeout(() => {
        if (snackbar.parentNode) {
          snackbar.parentNode.removeChild(snackbar);
        }
        this.snackbars.delete(id);
      }, 300);
    }

    hideAll() {
      this.snackbars.forEach((snackbar, id) => {
        this.hide(id);
      });
    }

    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // 편의 메서드들
    success(message, duration = 4000) {
      return this.show(message, 'success', duration);
    }

    error(message, duration = 6000) {
      return this.show(message, 'error', duration);
    }

    warning(message, duration = 5000) {
      return this.show(message, 'warning', duration);
    }

    info(message, duration = 4000) {
      return this.show(message, 'info', duration);
    }
  }

  // 전역 인스턴스 생성
  window.snackbarManager = new SnackbarManager();
</script>